<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Total Control Voice & Soundboard</title>
<style>
    :root { 
        --p: #00ff41; /* Hacker Green */
        --s: #003300; 
        --bg: #050505; 
        --panel: #111; 
        --danger: #ff3333;
    }
    body {
        background: var(--bg); color: var(--p);
        font-family: 'Consolas', 'Courier New', monospace;
        display: flex; flex-direction: column;
        height: 100vh; margin: 0; overflow: hidden; user-select: none;
    }

    /* --- HUD & HEADER --- */
    .hud {
        padding: 15px; background: #000; border-bottom: 2px solid var(--p);
        display: flex; gap: 15px; align-items: center;
        box-shadow: 0 0 20px var(--s); z-index: 10;
    }

    h1 { margin: 0; font-size: 20px; white-space: nowrap; color: white; text-shadow: 0 0 5px var(--p); }

    .btn {
        background: #001100; color: var(--p); border: 1px solid var(--p);
        padding: 8px 15px; cursor: pointer; font-weight: bold; text-transform: uppercase;
        transition: 0.2s; font-family: inherit; font-size: 12px;
    }
    .btn:hover { background: var(--p); color: black; box-shadow: 0 0 10px var(--p); }
    .btn:disabled { border-color: #444; color: #444; cursor: not-allowed; box-shadow: none; }
    
    .btn-danger { border-color: var(--danger); color: var(--danger); }
    .btn-danger:hover { background: var(--danger); color: white; box-shadow: 0 0 10px var(--danger); }
    .btn-danger.active { background: var(--danger); color: white; animation: pulse 1s infinite; }

    @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }

    /* --- VISUALIZER --- */
    canvas { height: 40px; width: 150px; background: #001100; border: 1px solid #004400; border-radius: 4px; }

    /* --- TABS --- */
    .tab-bar { display: flex; background: #0a0a0a; border-bottom: 1px solid #333; }
    .tab-btn {
        flex: 1; padding: 15px; background: transparent; color: #666; 
        border: none; cursor: pointer; font-size: 16px; font-weight: bold;
        border-bottom: 3px solid transparent; transition: 0.2s;
    }
    .tab-btn:hover { color: white; background: #111; }
    .tab-btn.active { color: var(--p); border-bottom: 3px solid var(--p); background: #0f1a0f; }

    /* --- CONTENT AREAS --- */
    .content-area { flex: 1; overflow-y: auto; padding: 20px; position: relative; display: none; }
    .content-area.show { display: block; }

    /* --- GRID & CARDS --- */
    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; }
    
    .card {
        background: var(--panel); border: 1px solid #333; padding: 10px;
        cursor: pointer; text-align: center; font-size: 12px;
        display: flex; flex-direction: column; justify-content: center; min-height: 60px;
        transition: 0.1s; position: relative; overflow: hidden;
    }
    .card:hover { border-color: white; background: #222; }
    .card.active { 
        background: var(--p); color: black; border-color: var(--p); 
        box-shadow: 0 0 15px var(--p); font-weight: bold;
    }
    
    /* FX CATEGORIES */
    .cat-robot { border-left: 3px solid cyan; }
    .cat-horror { border-left: 3px solid red; }
    .cat-env { border-left: 3px solid orange; }
    .cat-sci { border-left: 3px solid violet; }
    .cat-tool { border-left: 3px solid white; }

    /* SFX SPECIFIC */
    .sfx-controls {
        display: flex; gap: 10px; margin-bottom: 20px; align-items: center;
        background: #111; padding: 10px; border-radius: 5px; border: 1px solid #333;
    }
    .card.playing { border-color: var(--p); background: #003300; }
    .delete-overlay {
        position: absolute; inset: 0; background: rgba(50,0,0,0.9);
        display: none; align-items: center; justify-content: center;
        color: red; font-weight: bold; font-size: 18px; border: 2px solid red;
    }
    .delete-mode .delete-overlay { display: flex; }

    input[type=range] { accent-color: var(--p); }
    .search-bar { width: 100%; padding: 10px; background: #111; border: 1px solid #333; color: white; margin-bottom: 10px; box-sizing: border-box; }

</style>
</head>
<body>

<!-- HEADER -->
<div class="hud">
    <h1>TOTAL CONTROL</h1>
    <canvas id="visualizer"></canvas>
    <button id="pwrBtn" class="btn" onclick="initSystem()">INITIALIZE SYSTEM</button>
    <div style="flex:1"></div>
    <small>STATUS: <span id="statusTxt" style="color:#666">OFFLINE</span></small>
</div>

<!-- TABS -->
<div class="tab-bar">
    <button class="tab-btn active" onclick="switchTab('voices', this)">VOICE DECK (100)</button>
    <button class="tab-btn" onclick="switchTab('sfx', this)">SOUNDBOARD (DB)</button>
</div>

<!-- VOICE TAB -->
<div id="tab-voices" class="content-area show">
    <input type="text" class="search-bar" placeholder="Search voices (e.g. Robot, Demon, Echo)..." onkeyup="filterVoices(this.value)">
    <div class="grid" id="voiceGrid"></div>
</div>

<!-- SOUNDBOARD TAB -->
<div id="tab-sfx" class="content-area">
    <div class="sfx-controls">
        <button class="btn" onclick="document.getElementById('fileInput').click()">+ IMPORT MP3/WAV</button>
        <button class="btn btn-danger" id="delBtn" onclick="toggleDeleteMode()">TRASH MODE: OFF</button>
        <div style="flex:1"></div>
        <label>SFX VOL:</label>
        <input type="range" min="0" max="2" step="0.1" value="1" oninput="setSfxVol(this.value)">
        <button class="btn btn-danger" onclick="stopAllSfx()">STOP ALL</button>
    </div>
    <div id="dbStatus" style="font-size:10px; color:#666; margin-bottom:10px;">Database Status: Waiting...</div>
    <div class="grid" id="sfxGrid"></div>
    <input type="file" id="fileInput" multiple accept="audio/*" style="display:none" onchange="importFiles(this.files)">
</div>

<script>
    // --- GLOBAL VARS ---
    let ac, micSource, masterOut, analyzer; // Audio Context stuff
    let sfxGain;
    let voiceNodes = [];
    let isRunning = false;
    let db;
    let isDeleteMode = false;
    
    const DB_NAME = "TotalControlDB";
    const STORE = "sounds";

    // --- INIT ---
    window.onload = () => {
        setupDB(); // Load DB immediately so sounds appear
    };

    function switchTab(id, btn) {
        document.querySelectorAll('.content-area').forEach(c => c.classList.remove('show'));
        document.getElementById('tab-'+id).classList.add('show');
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
    }

    async function initSystem() {
        if(isRunning) { window.location.reload(); return; }
        try {
            const AC = window.AudioContext || window.webkitAudioContext;
            ac = new AC();
            
            // Mic
            const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false } });
            micSource = ac.createMediaStreamSource(stream);
            
            // Master & SFX
            masterOut = ac.createGain();
            masterOut.connect(ac.destination);
            
            sfxGain = ac.createGain();
            sfxGain.connect(masterOut);

            // Visualizer
            analyzer = ac.createAnalyser();
            analyzer.fftSize = 256;
            masterOut.connect(analyzer);
            drawVisualizer();

            // UI Updates
            isRunning = true;
            document.getElementById('pwrBtn').innerText = "POWER OFF";
            document.getElementById('pwrBtn').style.borderColor = "red";
            document.getElementById('statusTxt').innerText = "ONLINE";
            document.getElementById('statusTxt').style.color = "#0f0";
            
            loadVoice(0); // Load Normal voice

        } catch(e) {
            alert("Mic Error: " + e);
        }
    }

    // --- DATABASE & SOUNDBOARD LOGIC ---
    function setupDB() {
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = e => {
            db = e.target.result;
            if(!db.objectStoreNames.contains(STORE)) {
                db.createObjectStore(STORE, { keyPath: "id", autoIncrement: true });
            }
        };
        req.onsuccess = e => {
            db = e.target.result;
            loadSounds();
        };
    }

    function importFiles(files) {
        if(!db) return;
        Array.from(files).forEach(f => {
            const reader = new FileReader();
            reader.onload = e => {
                const tx = db.transaction(STORE, "readwrite");
                tx.objectStore(STORE).add({
                    name: f.name.replace(/\.[^/.]+$/, "").substring(0, 15),
                    data: e.target.result,
                    type: f.type
                });
                tx.oncomplete = () => loadSounds();
            };
            reader.readAsArrayBuffer(f);
        });
    }

    function loadSounds() {
        const tx = db.transaction(STORE, "readonly");
        const req = tx.objectStore(STORE).getAll();
        req.onsuccess = () => {
            const grid = document.getElementById('sfxGrid');
            grid.innerHTML = "";
            const sounds = req.result;
            document.getElementById('dbStatus').innerText = `${sounds.length} Saved Files Loaded.`;
            
            sounds.forEach(s => {
                const div = document.createElement('div');
                div.className = isDeleteMode ? "card delete-mode" : "card";
                div.innerHTML = `<b>${s.name}</b><div class="delete-overlay">DELETE</div>`;
                
                // Blob creation for playback
                const blob = new Blob([s.data], { type: s.type });
                const url = URL.createObjectURL(blob);
                
                div.onclick = () => {
                    if(isDeleteMode) deleteSound(s.id);
                    else playSfx(url, div);
                };
                grid.appendChild(div);
            });
        };
    }

    function deleteSound(id) {
        const tx = db.transaction(STORE, "readwrite");
        tx.objectStore(STORE).delete(id);
        tx.oncomplete = () => loadSounds();
    }

    function toggleDeleteMode() {
        isDeleteMode = !isDeleteMode;
        const btn = document.getElementById('delBtn');
        if(isDeleteMode) {
            btn.classList.add('active');
            btn.innerText = "DONE DELETING";
            document.querySelectorAll('#sfxGrid .card').forEach(c => c.classList.add('delete-mode'));
        } else {
            btn.classList.remove('active');
            btn.innerText = "TRASH MODE: OFF";
            document.querySelectorAll('#sfxGrid .card').forEach(c => c.classList.remove('delete-mode'));
        }
    }

    function playSfx(url, div) {
        if(!isRunning) { alert("Turn on System First!"); return; }
        const audio = new Audio(url);
        const src = ac.createMediaElementSource(audio);
        src.connect(sfxGain);
        audio.play();
        div.classList.add('playing');
        audio.onended = () => div.classList.remove('playing');
    }

    function stopAllSfx() {
        // Quick mute trick as we don't track all audio elements
        if(!sfxGain) return;
        const v = sfxGain.gain.value;
        sfxGain.gain.value = 0;
        setTimeout(() => sfxGain.gain.value = v, 200);
    }
    
    function setSfxVol(v) { if(sfxGain) sfxGain.gain.value = v; }


    // --- 100 VOICES GENERATOR ---
    const voiceLib = [
        {name: "Normal", cat: "tool", fx: []},
        {name: "Robot - Classic", cat: "robot", fx: ["ring:50"]},
        {name: "Robot - Deep", cat: "robot", fx: ["ring:30", "lp:500"]},
        {name: "Robot - Buzz", cat: "robot", fx: ["ring:100:saw"]},
        {name: "Demon - Lord", cat: "horror", fx: ["lp:400", "dist:200"]},
        {name: "Demon - Growl", cat: "horror", fx: ["dist:400", "lp:800"]},
        {name: "Ghost - Ethereal", cat: "horror", fx: ["echo:0.3:0.6", "hp:500"]},
        {name: "Alien - Wobble", cat: "sci", fx: ["vibe:10:200"]},
        {name: "Alien - Insect", cat: "sci", fx: ["ring:200:saw"]},
        {name: "Cave Echo", cat: "env", fx: ["echo:0.5:0.4"]},
        {name: "Radio", cat: "tool", fx: ["bp:1000:2", "dist:50"]},
        {name: "Telephone", cat: "tool", fx: ["bp:1500:1"]},
        {name: "Underwater", cat: "env", fx: ["lp:300", "vibe:1:200"]},
    ];

    // Procedural Generation for remaining voices
    for(let i=voiceLib.length; i<100; i++) {
        const types = ['robot', 'horror', 'sci', 'tool'];
        const t = types[i%4];
        const seed = i * 5;
        let effects = [];
        
        if(t==='robot') effects = [`ring:${30+seed%200}`];
        if(t==='horror') effects = [`dist:${50+seed}`, `lp:${1000-seed*2}`];
        if(t==='sci') effects = [`vibe:${5 + seed%20}:${100+seed}`];
        if(t==='tool') effects = [`bp:${500+seed*10}:2`];
        
        // Add random echos to some
        if(i%3===0) effects.push(`echo:0.${i%9}:0.4`);

        voiceLib.push({
            name: `Variant ${t.toUpperCase()} #${i}`,
            cat: t,
            fx: effects
        });
    }

    // Render Voice Grid
    const vGrid = document.getElementById('voiceGrid');
    voiceLib.forEach((v, i) => {
        const d = document.createElement('div');
        d.className = `card cat-${v.cat}`;
        d.innerHTML = `<b>${v.name}</b><span style="opacity:0.6;font-size:10px">${v.fx.length} FX</span>`;
        d.id = `vcard-${i}`;
        d.onclick = () => loadVoice(i);
        vGrid.appendChild(d);
    });

    function filterVoices(txt) {
        txt = txt.toLowerCase();
        voiceLib.forEach((v, i) => {
            const el = document.getElementById(`vcard-${i}`);
            el.style.display = (v.name.toLowerCase().includes(txt) || v.cat.includes(txt)) ? "flex" : "none";
        });
    }

    function loadVoice(idx) {
        if(!isRunning) return;
        // UI
        document.querySelectorAll('#voiceGrid .card').forEach(c => c.classList.remove('active'));
        document.getElementById(`vcard-${idx}`).classList.add('active');

        // Audio
        voiceNodes.forEach(n => n.disconnect());
        voiceNodes = [];
        let last = micSource;
        const v = voiceLib[idx];

        v.fx.forEach(f => {
            const p = f.split(':');
            let n = null;
            if(p[0] === 'dist') {
                n = ac.createWaveShaper(); n.curve = makeDistortionCurve(parseInt(p[1]));
            } else if(p[0] === 'ring') {
                n = ac.createGain(); n.gain.value = 0;
                let o = ac.createOscillator(); o.frequency.value = parseInt(p[1]); 
                if(p[2]) o.type = p[2];
                o.start(); o.connect(n.gain); voiceNodes.push(o);
            } else if(p[0] === 'echo') {
                n = ac.createDelay(); n.delayTime.value = parseFloat(p[1]);
                let fb = ac.createGain(); fb.gain.value = parseFloat(p[2]);
                n.connect(fb); fb.connect(n);
                // Insert delay logic (Parallel)
                // For simplicity in chain: Input -> Delay -> Output AND Input -> Output
                // We'll treat this as insert for code simplicity, works as echo
            } else if(p[0] === 'lp' || p[0] === 'hp' || p[0] === 'bp') {
                n = ac.createBiquadFilter(); 
                n.type = p[0] === 'lp' ? 'lowpass' : (p[0] === 'hp' ? 'highpass' : 'bandpass');
                n.frequency.value = parseInt(p[1]);
                if(p[2]) n.Q.value = parseFloat(p[2]);
            } else if(p[0] === 'vibe') {
                n = ac.createGain();
                let o = ac.createOscillator(); o.frequency.value = parseFloat(p[1]); o.start();
                let d = ac.createGain(); d.gain.value = parseFloat(p[2]);
                o.connect(d); d.connect(n.gain); voiceNodes.push(o, d);
            }

            if(n) {
                last.connect(n);
                last = n;
                voiceNodes.push(n);
            }
        });
        last.connect(masterOut);
    }

    function makeDistortionCurve(k) {
        let n = 44100, curve = new Float32Array(n), deg = Math.PI / 180;
        for (let i = 0; i < n; ++i) {
            let x = i * 2 / n - 1;
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
    }

    function drawVisualizer() {
        if(!isRunning) return;
        requestAnimationFrame(drawVisualizer);
        const data = new Uint8Array(analyzer.frequencyBinCount);
        analyzer.getByteTimeDomainData(data);
        const ctx = document.getElementById('visualizer').getContext('2d');
        const w = ctx.canvas.width; const h = ctx.canvas.height;
        ctx.fillStyle = '#001100'; ctx.fillRect(0,0,w,h);
        ctx.lineWidth = 2; ctx.strokeStyle = '#00ff41'; ctx.beginPath();
        let x = 0; const slice = w * 1.0 / data.length;
        for(let i=0; i<data.length; i++) {
            let v = data[i]/128.0; let y = v*h/2;
            if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            x+=slice;
        }
        ctx.stroke();
    }
</script>
</body>
</html>
